/*
Ceph REST API

This is the official Ceph REST API

API version: v1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package ceph

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// RgwBucketAPIService RgwBucketAPI service
type RgwBucketAPIService service

type ApiApiRgwBucketBucketDeleteRequest struct {
	ctx context.Context
	ApiService *RgwBucketAPIService
	bucket string
	purgeObjects *string
	daemonName *string
}

func (r ApiApiRgwBucketBucketDeleteRequest) PurgeObjects(purgeObjects string) ApiApiRgwBucketBucketDeleteRequest {
	r.purgeObjects = &purgeObjects
	return r
}

func (r ApiApiRgwBucketBucketDeleteRequest) DaemonName(daemonName string) ApiApiRgwBucketBucketDeleteRequest {
	r.daemonName = &daemonName
	return r
}

func (r ApiApiRgwBucketBucketDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiRgwBucketBucketDeleteExecute(r)
}

/*
ApiRgwBucketBucketDelete Method for ApiRgwBucketBucketDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bucket
 @return ApiApiRgwBucketBucketDeleteRequest
*/
func (a *RgwBucketAPIService) ApiRgwBucketBucketDelete(ctx context.Context, bucket string) ApiApiRgwBucketBucketDeleteRequest {
	return ApiApiRgwBucketBucketDeleteRequest{
		ApiService: a,
		ctx: ctx,
		bucket: bucket,
	}
}

// Execute executes the request
func (a *RgwBucketAPIService) ApiRgwBucketBucketDeleteExecute(r ApiApiRgwBucketBucketDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RgwBucketAPIService.ApiRgwBucketBucketDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/rgw/bucket/{bucket}"
	localVarPath = strings.Replace(localVarPath, "{"+"bucket"+"}", url.PathEscape(parameterValueToString(r.bucket, "bucket")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.purgeObjects != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "purge_objects", r.purgeObjects, "form", "")
	}
	if r.daemonName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "daemon_name", r.daemonName, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.ceph.api.v1.0+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiRgwBucketBucketGetRequest struct {
	ctx context.Context
	ApiService *RgwBucketAPIService
	bucket string
	daemonName *string
}

func (r ApiApiRgwBucketBucketGetRequest) DaemonName(daemonName string) ApiApiRgwBucketBucketGetRequest {
	r.daemonName = &daemonName
	return r
}

func (r ApiApiRgwBucketBucketGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiRgwBucketBucketGetExecute(r)
}

/*
ApiRgwBucketBucketGet Method for ApiRgwBucketBucketGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bucket
 @return ApiApiRgwBucketBucketGetRequest
*/
func (a *RgwBucketAPIService) ApiRgwBucketBucketGet(ctx context.Context, bucket string) ApiApiRgwBucketBucketGetRequest {
	return ApiApiRgwBucketBucketGetRequest{
		ApiService: a,
		ctx: ctx,
		bucket: bucket,
	}
}

// Execute executes the request
func (a *RgwBucketAPIService) ApiRgwBucketBucketGetExecute(r ApiApiRgwBucketBucketGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RgwBucketAPIService.ApiRgwBucketBucketGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/rgw/bucket/{bucket}"
	localVarPath = strings.Replace(localVarPath, "{"+"bucket"+"}", url.PathEscape(parameterValueToString(r.bucket, "bucket")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.daemonName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "daemon_name", r.daemonName, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.ceph.api.v1.0+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiRgwBucketBucketPutRequest struct {
	ctx context.Context
	ApiService *RgwBucketAPIService
	bucket string
	apiRgwBucketBucketPutRequest *ApiRgwBucketBucketPutRequest
}

func (r ApiApiRgwBucketBucketPutRequest) ApiRgwBucketBucketPutRequest(apiRgwBucketBucketPutRequest ApiRgwBucketBucketPutRequest) ApiApiRgwBucketBucketPutRequest {
	r.apiRgwBucketBucketPutRequest = &apiRgwBucketBucketPutRequest
	return r
}

func (r ApiApiRgwBucketBucketPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiRgwBucketBucketPutExecute(r)
}

/*
ApiRgwBucketBucketPut Method for ApiRgwBucketBucketPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bucket
 @return ApiApiRgwBucketBucketPutRequest
*/
func (a *RgwBucketAPIService) ApiRgwBucketBucketPut(ctx context.Context, bucket string) ApiApiRgwBucketBucketPutRequest {
	return ApiApiRgwBucketBucketPutRequest{
		ApiService: a,
		ctx: ctx,
		bucket: bucket,
	}
}

// Execute executes the request
func (a *RgwBucketAPIService) ApiRgwBucketBucketPutExecute(r ApiApiRgwBucketBucketPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RgwBucketAPIService.ApiRgwBucketBucketPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/rgw/bucket/{bucket}"
	localVarPath = strings.Replace(localVarPath, "{"+"bucket"+"}", url.PathEscape(parameterValueToString(r.bucket, "bucket")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.ceph.api.v1.0+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiRgwBucketBucketPutRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiRgwBucketDeleteEncryptionDeleteRequest struct {
	ctx context.Context
	ApiService *RgwBucketAPIService
	bucketName *string
	daemonName *string
	owner *string
}

func (r ApiApiRgwBucketDeleteEncryptionDeleteRequest) BucketName(bucketName string) ApiApiRgwBucketDeleteEncryptionDeleteRequest {
	r.bucketName = &bucketName
	return r
}

func (r ApiApiRgwBucketDeleteEncryptionDeleteRequest) DaemonName(daemonName string) ApiApiRgwBucketDeleteEncryptionDeleteRequest {
	r.daemonName = &daemonName
	return r
}

func (r ApiApiRgwBucketDeleteEncryptionDeleteRequest) Owner(owner string) ApiApiRgwBucketDeleteEncryptionDeleteRequest {
	r.owner = &owner
	return r
}

func (r ApiApiRgwBucketDeleteEncryptionDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiRgwBucketDeleteEncryptionDeleteExecute(r)
}

/*
ApiRgwBucketDeleteEncryptionDelete Method for ApiRgwBucketDeleteEncryptionDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiRgwBucketDeleteEncryptionDeleteRequest
*/
func (a *RgwBucketAPIService) ApiRgwBucketDeleteEncryptionDelete(ctx context.Context) ApiApiRgwBucketDeleteEncryptionDeleteRequest {
	return ApiApiRgwBucketDeleteEncryptionDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *RgwBucketAPIService) ApiRgwBucketDeleteEncryptionDeleteExecute(r ApiApiRgwBucketDeleteEncryptionDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RgwBucketAPIService.ApiRgwBucketDeleteEncryptionDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/rgw/bucket/deleteEncryption"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bucketName == nil {
		return nil, reportError("bucketName is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "bucket_name", r.bucketName, "form", "")
	if r.daemonName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "daemon_name", r.daemonName, "form", "")
	}
	if r.owner != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "owner", r.owner, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.ceph.api.v1.0+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiRgwBucketGetRequest struct {
	ctx context.Context
	ApiService *RgwBucketAPIService
	stats *bool
	daemonName *string
	uid *string
}

func (r ApiApiRgwBucketGetRequest) Stats(stats bool) ApiApiRgwBucketGetRequest {
	r.stats = &stats
	return r
}

func (r ApiApiRgwBucketGetRequest) DaemonName(daemonName string) ApiApiRgwBucketGetRequest {
	r.daemonName = &daemonName
	return r
}

func (r ApiApiRgwBucketGetRequest) Uid(uid string) ApiApiRgwBucketGetRequest {
	r.uid = &uid
	return r
}

func (r ApiApiRgwBucketGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiRgwBucketGetExecute(r)
}

/*
ApiRgwBucketGet Method for ApiRgwBucketGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiRgwBucketGetRequest
*/
func (a *RgwBucketAPIService) ApiRgwBucketGet(ctx context.Context) ApiApiRgwBucketGetRequest {
	return ApiApiRgwBucketGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *RgwBucketAPIService) ApiRgwBucketGetExecute(r ApiApiRgwBucketGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RgwBucketAPIService.ApiRgwBucketGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/rgw/bucket"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.stats != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stats", r.stats, "form", "")
	}
	if r.daemonName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "daemon_name", r.daemonName, "form", "")
	}
	if r.uid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "uid", r.uid, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.ceph.api.v1.1+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiRgwBucketGetEncryptionConfigGetRequest struct {
	ctx context.Context
	ApiService *RgwBucketAPIService
	daemonName *string
	owner *string
}

func (r ApiApiRgwBucketGetEncryptionConfigGetRequest) DaemonName(daemonName string) ApiApiRgwBucketGetEncryptionConfigGetRequest {
	r.daemonName = &daemonName
	return r
}

func (r ApiApiRgwBucketGetEncryptionConfigGetRequest) Owner(owner string) ApiApiRgwBucketGetEncryptionConfigGetRequest {
	r.owner = &owner
	return r
}

func (r ApiApiRgwBucketGetEncryptionConfigGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiRgwBucketGetEncryptionConfigGetExecute(r)
}

/*
ApiRgwBucketGetEncryptionConfigGet Method for ApiRgwBucketGetEncryptionConfigGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiRgwBucketGetEncryptionConfigGetRequest
*/
func (a *RgwBucketAPIService) ApiRgwBucketGetEncryptionConfigGet(ctx context.Context) ApiApiRgwBucketGetEncryptionConfigGetRequest {
	return ApiApiRgwBucketGetEncryptionConfigGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *RgwBucketAPIService) ApiRgwBucketGetEncryptionConfigGetExecute(r ApiApiRgwBucketGetEncryptionConfigGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RgwBucketAPIService.ApiRgwBucketGetEncryptionConfigGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/rgw/bucket/getEncryptionConfig"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.daemonName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "daemon_name", r.daemonName, "form", "")
	}
	if r.owner != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "owner", r.owner, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.ceph.api.v1.0+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiRgwBucketGetEncryptionGetRequest struct {
	ctx context.Context
	ApiService *RgwBucketAPIService
	bucketName *string
	daemonName *string
	owner *string
}

func (r ApiApiRgwBucketGetEncryptionGetRequest) BucketName(bucketName string) ApiApiRgwBucketGetEncryptionGetRequest {
	r.bucketName = &bucketName
	return r
}

func (r ApiApiRgwBucketGetEncryptionGetRequest) DaemonName(daemonName string) ApiApiRgwBucketGetEncryptionGetRequest {
	r.daemonName = &daemonName
	return r
}

func (r ApiApiRgwBucketGetEncryptionGetRequest) Owner(owner string) ApiApiRgwBucketGetEncryptionGetRequest {
	r.owner = &owner
	return r
}

func (r ApiApiRgwBucketGetEncryptionGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiRgwBucketGetEncryptionGetExecute(r)
}

/*
ApiRgwBucketGetEncryptionGet Method for ApiRgwBucketGetEncryptionGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiRgwBucketGetEncryptionGetRequest
*/
func (a *RgwBucketAPIService) ApiRgwBucketGetEncryptionGet(ctx context.Context) ApiApiRgwBucketGetEncryptionGetRequest {
	return ApiApiRgwBucketGetEncryptionGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *RgwBucketAPIService) ApiRgwBucketGetEncryptionGetExecute(r ApiApiRgwBucketGetEncryptionGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RgwBucketAPIService.ApiRgwBucketGetEncryptionGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/rgw/bucket/getEncryption"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bucketName == nil {
		return nil, reportError("bucketName is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "bucket_name", r.bucketName, "form", "")
	if r.daemonName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "daemon_name", r.daemonName, "form", "")
	}
	if r.owner != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "owner", r.owner, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.ceph.api.v1.0+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiRgwBucketPostRequest struct {
	ctx context.Context
	ApiService *RgwBucketAPIService
	apiRgwBucketPostRequest *ApiRgwBucketPostRequest
}

func (r ApiApiRgwBucketPostRequest) ApiRgwBucketPostRequest(apiRgwBucketPostRequest ApiRgwBucketPostRequest) ApiApiRgwBucketPostRequest {
	r.apiRgwBucketPostRequest = &apiRgwBucketPostRequest
	return r
}

func (r ApiApiRgwBucketPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiRgwBucketPostExecute(r)
}

/*
ApiRgwBucketPost Method for ApiRgwBucketPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiRgwBucketPostRequest
*/
func (a *RgwBucketAPIService) ApiRgwBucketPost(ctx context.Context) ApiApiRgwBucketPostRequest {
	return ApiApiRgwBucketPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *RgwBucketAPIService) ApiRgwBucketPostExecute(r ApiApiRgwBucketPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RgwBucketAPIService.ApiRgwBucketPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/rgw/bucket"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.ceph.api.v1.0+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiRgwBucketPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiRgwBucketSetEncryptionConfigPutRequest struct {
	ctx context.Context
	ApiService *RgwBucketAPIService
	apiRgwBucketSetEncryptionConfigPutRequest *ApiRgwBucketSetEncryptionConfigPutRequest
}

func (r ApiApiRgwBucketSetEncryptionConfigPutRequest) ApiRgwBucketSetEncryptionConfigPutRequest(apiRgwBucketSetEncryptionConfigPutRequest ApiRgwBucketSetEncryptionConfigPutRequest) ApiApiRgwBucketSetEncryptionConfigPutRequest {
	r.apiRgwBucketSetEncryptionConfigPutRequest = &apiRgwBucketSetEncryptionConfigPutRequest
	return r
}

func (r ApiApiRgwBucketSetEncryptionConfigPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiRgwBucketSetEncryptionConfigPutExecute(r)
}

/*
ApiRgwBucketSetEncryptionConfigPut Method for ApiRgwBucketSetEncryptionConfigPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiRgwBucketSetEncryptionConfigPutRequest
*/
func (a *RgwBucketAPIService) ApiRgwBucketSetEncryptionConfigPut(ctx context.Context) ApiApiRgwBucketSetEncryptionConfigPutRequest {
	return ApiApiRgwBucketSetEncryptionConfigPutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *RgwBucketAPIService) ApiRgwBucketSetEncryptionConfigPutExecute(r ApiApiRgwBucketSetEncryptionConfigPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RgwBucketAPIService.ApiRgwBucketSetEncryptionConfigPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/rgw/bucket/setEncryptionConfig"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.ceph.api.v1.0+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiRgwBucketSetEncryptionConfigPutRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
