/*
Ceph REST API

This is the official Ceph REST API

API version: v1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package ceph

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// MultiClusterAPIService MultiClusterAPI service
type MultiClusterAPIService service

type ApiApiMultiClusterAuthPostRequest struct {
	ctx context.Context
	ApiService *MultiClusterAPIService
	apiMultiClusterAuthPostRequest *ApiMultiClusterAuthPostRequest
}

func (r ApiApiMultiClusterAuthPostRequest) ApiMultiClusterAuthPostRequest(apiMultiClusterAuthPostRequest ApiMultiClusterAuthPostRequest) ApiApiMultiClusterAuthPostRequest {
	r.apiMultiClusterAuthPostRequest = &apiMultiClusterAuthPostRequest
	return r
}

func (r ApiApiMultiClusterAuthPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiMultiClusterAuthPostExecute(r)
}

/*
ApiMultiClusterAuthPost Authenticate to a remote cluster

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiMultiClusterAuthPostRequest
*/
func (a *MultiClusterAPIService) ApiMultiClusterAuthPost(ctx context.Context) ApiApiMultiClusterAuthPostRequest {
	return ApiApiMultiClusterAuthPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *MultiClusterAPIService) ApiMultiClusterAuthPostExecute(r ApiApiMultiClusterAuthPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MultiClusterAPIService.ApiMultiClusterAuthPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/multi-cluster/auth"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.ceph.api.v1.0+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiMultiClusterAuthPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiMultiClusterCheckTokenStatusGetRequest struct {
	ctx context.Context
	ApiService *MultiClusterAPIService
	clustersTokenMap *string
}

func (r ApiApiMultiClusterCheckTokenStatusGetRequest) ClustersTokenMap(clustersTokenMap string) ApiApiMultiClusterCheckTokenStatusGetRequest {
	r.clustersTokenMap = &clustersTokenMap
	return r
}

func (r ApiApiMultiClusterCheckTokenStatusGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiMultiClusterCheckTokenStatusGetExecute(r)
}

/*
ApiMultiClusterCheckTokenStatusGet Method for ApiMultiClusterCheckTokenStatusGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiMultiClusterCheckTokenStatusGetRequest
*/
func (a *MultiClusterAPIService) ApiMultiClusterCheckTokenStatusGet(ctx context.Context) ApiApiMultiClusterCheckTokenStatusGetRequest {
	return ApiApiMultiClusterCheckTokenStatusGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *MultiClusterAPIService) ApiMultiClusterCheckTokenStatusGetExecute(r ApiApiMultiClusterCheckTokenStatusGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MultiClusterAPIService.ApiMultiClusterCheckTokenStatusGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/multi-cluster/check_token_status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.clustersTokenMap != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "clustersTokenMap", r.clustersTokenMap, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.ceph.api.v1.0+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiMultiClusterDeleteClusterClusterNameClusterUserDeleteRequest struct {
	ctx context.Context
	ApiService *MultiClusterAPIService
	clusterName string
	clusterUser string
}

func (r ApiApiMultiClusterDeleteClusterClusterNameClusterUserDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiMultiClusterDeleteClusterClusterNameClusterUserDeleteExecute(r)
}

/*
ApiMultiClusterDeleteClusterClusterNameClusterUserDelete Method for ApiMultiClusterDeleteClusterClusterNameClusterUserDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clusterName
 @param clusterUser
 @return ApiApiMultiClusterDeleteClusterClusterNameClusterUserDeleteRequest
*/
func (a *MultiClusterAPIService) ApiMultiClusterDeleteClusterClusterNameClusterUserDelete(ctx context.Context, clusterName string, clusterUser string) ApiApiMultiClusterDeleteClusterClusterNameClusterUserDeleteRequest {
	return ApiApiMultiClusterDeleteClusterClusterNameClusterUserDeleteRequest{
		ApiService: a,
		ctx: ctx,
		clusterName: clusterName,
		clusterUser: clusterUser,
	}
}

// Execute executes the request
func (a *MultiClusterAPIService) ApiMultiClusterDeleteClusterClusterNameClusterUserDeleteExecute(r ApiApiMultiClusterDeleteClusterClusterNameClusterUserDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MultiClusterAPIService.ApiMultiClusterDeleteClusterClusterNameClusterUserDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/multi-cluster/delete_cluster/{cluster_name}/{cluster_user}"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_name"+"}", url.PathEscape(parameterValueToString(r.clusterName, "clusterName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_user"+"}", url.PathEscape(parameterValueToString(r.clusterUser, "clusterUser")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.ceph.api.v1.0+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiMultiClusterEditClusterPutRequest struct {
	ctx context.Context
	ApiService *MultiClusterAPIService
	apiMultiClusterEditClusterPutRequest *ApiMultiClusterEditClusterPutRequest
}

func (r ApiApiMultiClusterEditClusterPutRequest) ApiMultiClusterEditClusterPutRequest(apiMultiClusterEditClusterPutRequest ApiMultiClusterEditClusterPutRequest) ApiApiMultiClusterEditClusterPutRequest {
	r.apiMultiClusterEditClusterPutRequest = &apiMultiClusterEditClusterPutRequest
	return r
}

func (r ApiApiMultiClusterEditClusterPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiMultiClusterEditClusterPutExecute(r)
}

/*
ApiMultiClusterEditClusterPut Method for ApiMultiClusterEditClusterPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiMultiClusterEditClusterPutRequest
*/
func (a *MultiClusterAPIService) ApiMultiClusterEditClusterPut(ctx context.Context) ApiApiMultiClusterEditClusterPutRequest {
	return ApiApiMultiClusterEditClusterPutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *MultiClusterAPIService) ApiMultiClusterEditClusterPutExecute(r ApiApiMultiClusterEditClusterPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MultiClusterAPIService.ApiMultiClusterEditClusterPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/multi-cluster/edit_cluster"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.ceph.api.v1.0+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiMultiClusterEditClusterPutRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiMultiClusterGetConfigGetRequest struct {
	ctx context.Context
	ApiService *MultiClusterAPIService
}

func (r ApiApiMultiClusterGetConfigGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiMultiClusterGetConfigGetExecute(r)
}

/*
ApiMultiClusterGetConfigGet Method for ApiMultiClusterGetConfigGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiMultiClusterGetConfigGetRequest
*/
func (a *MultiClusterAPIService) ApiMultiClusterGetConfigGet(ctx context.Context) ApiApiMultiClusterGetConfigGetRequest {
	return ApiApiMultiClusterGetConfigGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *MultiClusterAPIService) ApiMultiClusterGetConfigGetExecute(r ApiApiMultiClusterGetConfigGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MultiClusterAPIService.ApiMultiClusterGetConfigGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/multi-cluster/get_config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.ceph.api.v1.0+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiMultiClusterGetPrometheusApiUrlGetRequest struct {
	ctx context.Context
	ApiService *MultiClusterAPIService
}

func (r ApiApiMultiClusterGetPrometheusApiUrlGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiMultiClusterGetPrometheusApiUrlGetExecute(r)
}

/*
ApiMultiClusterGetPrometheusApiUrlGet Method for ApiMultiClusterGetPrometheusApiUrlGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiMultiClusterGetPrometheusApiUrlGetRequest
*/
func (a *MultiClusterAPIService) ApiMultiClusterGetPrometheusApiUrlGet(ctx context.Context) ApiApiMultiClusterGetPrometheusApiUrlGetRequest {
	return ApiApiMultiClusterGetPrometheusApiUrlGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *MultiClusterAPIService) ApiMultiClusterGetPrometheusApiUrlGetExecute(r ApiApiMultiClusterGetPrometheusApiUrlGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MultiClusterAPIService.ApiMultiClusterGetPrometheusApiUrlGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/multi-cluster/get_prometheus_api_url"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.ceph.api.v1.0+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiMultiClusterReconnectClusterPutRequest struct {
	ctx context.Context
	ApiService *MultiClusterAPIService
	apiMultiClusterReconnectClusterPutRequest *ApiMultiClusterReconnectClusterPutRequest
}

func (r ApiApiMultiClusterReconnectClusterPutRequest) ApiMultiClusterReconnectClusterPutRequest(apiMultiClusterReconnectClusterPutRequest ApiMultiClusterReconnectClusterPutRequest) ApiApiMultiClusterReconnectClusterPutRequest {
	r.apiMultiClusterReconnectClusterPutRequest = &apiMultiClusterReconnectClusterPutRequest
	return r
}

func (r ApiApiMultiClusterReconnectClusterPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiMultiClusterReconnectClusterPutExecute(r)
}

/*
ApiMultiClusterReconnectClusterPut Method for ApiMultiClusterReconnectClusterPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiMultiClusterReconnectClusterPutRequest
*/
func (a *MultiClusterAPIService) ApiMultiClusterReconnectClusterPut(ctx context.Context) ApiApiMultiClusterReconnectClusterPutRequest {
	return ApiApiMultiClusterReconnectClusterPutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *MultiClusterAPIService) ApiMultiClusterReconnectClusterPutExecute(r ApiApiMultiClusterReconnectClusterPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MultiClusterAPIService.ApiMultiClusterReconnectClusterPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/multi-cluster/reconnect_cluster"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.ceph.api.v1.0+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiMultiClusterReconnectClusterPutRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiMultiClusterSecurityConfigGetRequest struct {
	ctx context.Context
	ApiService *MultiClusterAPIService
}

func (r ApiApiMultiClusterSecurityConfigGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiMultiClusterSecurityConfigGetExecute(r)
}

/*
ApiMultiClusterSecurityConfigGet Method for ApiMultiClusterSecurityConfigGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiMultiClusterSecurityConfigGetRequest
*/
func (a *MultiClusterAPIService) ApiMultiClusterSecurityConfigGet(ctx context.Context) ApiApiMultiClusterSecurityConfigGetRequest {
	return ApiApiMultiClusterSecurityConfigGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *MultiClusterAPIService) ApiMultiClusterSecurityConfigGetExecute(r ApiApiMultiClusterSecurityConfigGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MultiClusterAPIService.ApiMultiClusterSecurityConfigGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/multi-cluster/security_config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.ceph.api.v1.0+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiMultiClusterSetConfigPutRequest struct {
	ctx context.Context
	ApiService *MultiClusterAPIService
	apiMgrModuleModuleNamePutRequest *ApiMgrModuleModuleNamePutRequest
}

func (r ApiApiMultiClusterSetConfigPutRequest) ApiMgrModuleModuleNamePutRequest(apiMgrModuleModuleNamePutRequest ApiMgrModuleModuleNamePutRequest) ApiApiMultiClusterSetConfigPutRequest {
	r.apiMgrModuleModuleNamePutRequest = &apiMgrModuleModuleNamePutRequest
	return r
}

func (r ApiApiMultiClusterSetConfigPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiMultiClusterSetConfigPutExecute(r)
}

/*
ApiMultiClusterSetConfigPut Method for ApiMultiClusterSetConfigPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiMultiClusterSetConfigPutRequest
*/
func (a *MultiClusterAPIService) ApiMultiClusterSetConfigPut(ctx context.Context) ApiApiMultiClusterSetConfigPutRequest {
	return ApiApiMultiClusterSetConfigPutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *MultiClusterAPIService) ApiMultiClusterSetConfigPutExecute(r ApiApiMultiClusterSetConfigPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MultiClusterAPIService.ApiMultiClusterSetConfigPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/multi-cluster/set_config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.ceph.api.v1.0+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiMgrModuleModuleNamePutRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
