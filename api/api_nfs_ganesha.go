/*
Ceph REST API

This is the official Ceph REST API

API version: v1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package ceph

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// NFSGaneshaAPIService NFSGaneshaAPI service
type NFSGaneshaAPIService service

type ApiApiNfsGaneshaClusterGetRequest struct {
	ctx context.Context
	ApiService *NFSGaneshaAPIService
}

func (r ApiApiNfsGaneshaClusterGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiNfsGaneshaClusterGetExecute(r)
}

/*
ApiNfsGaneshaClusterGet Method for ApiNfsGaneshaClusterGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiNfsGaneshaClusterGetRequest
*/
func (a *NFSGaneshaAPIService) ApiNfsGaneshaClusterGet(ctx context.Context) ApiApiNfsGaneshaClusterGetRequest {
	return ApiApiNfsGaneshaClusterGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *NFSGaneshaAPIService) ApiNfsGaneshaClusterGetExecute(r ApiApiNfsGaneshaClusterGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NFSGaneshaAPIService.ApiNfsGaneshaClusterGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/nfs-ganesha/cluster"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.ceph.api.v0.1+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiNfsGaneshaExportClusterIdExportIdDeleteRequest struct {
	ctx context.Context
	ApiService *NFSGaneshaAPIService
	clusterId string
	exportId int32
}

func (r ApiApiNfsGaneshaExportClusterIdExportIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiNfsGaneshaExportClusterIdExportIdDeleteExecute(r)
}

/*
ApiNfsGaneshaExportClusterIdExportIdDelete Deletes an NFS-Ganesha export

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clusterId Cluster identifier
 @param exportId Export ID
 @return ApiApiNfsGaneshaExportClusterIdExportIdDeleteRequest
*/
func (a *NFSGaneshaAPIService) ApiNfsGaneshaExportClusterIdExportIdDelete(ctx context.Context, clusterId string, exportId int32) ApiApiNfsGaneshaExportClusterIdExportIdDeleteRequest {
	return ApiApiNfsGaneshaExportClusterIdExportIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		clusterId: clusterId,
		exportId: exportId,
	}
}

// Execute executes the request
func (a *NFSGaneshaAPIService) ApiNfsGaneshaExportClusterIdExportIdDeleteExecute(r ApiApiNfsGaneshaExportClusterIdExportIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NFSGaneshaAPIService.ApiNfsGaneshaExportClusterIdExportIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/nfs-ganesha/export/{cluster_id}/{export_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_id"+"}", url.PathEscape(parameterValueToString(r.clusterId, "clusterId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"export_id"+"}", url.PathEscape(parameterValueToString(r.exportId, "exportId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.ceph.api.v2.0+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiNfsGaneshaExportClusterIdExportIdGetRequest struct {
	ctx context.Context
	ApiService *NFSGaneshaAPIService
	clusterId string
	exportId string
}

func (r ApiApiNfsGaneshaExportClusterIdExportIdGetRequest) Execute() (*ApiNfsGaneshaExportPost201Response, *http.Response, error) {
	return r.ApiService.ApiNfsGaneshaExportClusterIdExportIdGetExecute(r)
}

/*
ApiNfsGaneshaExportClusterIdExportIdGet Get an NFS-Ganesha export

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clusterId Cluster identifier
 @param exportId Export ID
 @return ApiApiNfsGaneshaExportClusterIdExportIdGetRequest
*/
func (a *NFSGaneshaAPIService) ApiNfsGaneshaExportClusterIdExportIdGet(ctx context.Context, clusterId string, exportId string) ApiApiNfsGaneshaExportClusterIdExportIdGetRequest {
	return ApiApiNfsGaneshaExportClusterIdExportIdGetRequest{
		ApiService: a,
		ctx: ctx,
		clusterId: clusterId,
		exportId: exportId,
	}
}

// Execute executes the request
//  @return ApiNfsGaneshaExportPost201Response
func (a *NFSGaneshaAPIService) ApiNfsGaneshaExportClusterIdExportIdGetExecute(r ApiApiNfsGaneshaExportClusterIdExportIdGetRequest) (*ApiNfsGaneshaExportPost201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiNfsGaneshaExportPost201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NFSGaneshaAPIService.ApiNfsGaneshaExportClusterIdExportIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/nfs-ganesha/export/{cluster_id}/{export_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_id"+"}", url.PathEscape(parameterValueToString(r.clusterId, "clusterId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"export_id"+"}", url.PathEscape(parameterValueToString(r.exportId, "exportId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.ceph.api.v1.0+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiNfsGaneshaExportClusterIdExportIdPutRequest struct {
	ctx context.Context
	ApiService *NFSGaneshaAPIService
	clusterId string
	exportId int32
	apiNfsGaneshaExportClusterIdExportIdPutRequest *ApiNfsGaneshaExportClusterIdExportIdPutRequest
}

func (r ApiApiNfsGaneshaExportClusterIdExportIdPutRequest) ApiNfsGaneshaExportClusterIdExportIdPutRequest(apiNfsGaneshaExportClusterIdExportIdPutRequest ApiNfsGaneshaExportClusterIdExportIdPutRequest) ApiApiNfsGaneshaExportClusterIdExportIdPutRequest {
	r.apiNfsGaneshaExportClusterIdExportIdPutRequest = &apiNfsGaneshaExportClusterIdExportIdPutRequest
	return r
}

func (r ApiApiNfsGaneshaExportClusterIdExportIdPutRequest) Execute() (*ApiNfsGaneshaExportPost201Response, *http.Response, error) {
	return r.ApiService.ApiNfsGaneshaExportClusterIdExportIdPutExecute(r)
}

/*
ApiNfsGaneshaExportClusterIdExportIdPut Updates an NFS-Ganesha export

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clusterId Cluster identifier
 @param exportId Export ID
 @return ApiApiNfsGaneshaExportClusterIdExportIdPutRequest
*/
func (a *NFSGaneshaAPIService) ApiNfsGaneshaExportClusterIdExportIdPut(ctx context.Context, clusterId string, exportId int32) ApiApiNfsGaneshaExportClusterIdExportIdPutRequest {
	return ApiApiNfsGaneshaExportClusterIdExportIdPutRequest{
		ApiService: a,
		ctx: ctx,
		clusterId: clusterId,
		exportId: exportId,
	}
}

// Execute executes the request
//  @return ApiNfsGaneshaExportPost201Response
func (a *NFSGaneshaAPIService) ApiNfsGaneshaExportClusterIdExportIdPutExecute(r ApiApiNfsGaneshaExportClusterIdExportIdPutRequest) (*ApiNfsGaneshaExportPost201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiNfsGaneshaExportPost201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NFSGaneshaAPIService.ApiNfsGaneshaExportClusterIdExportIdPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/nfs-ganesha/export/{cluster_id}/{export_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_id"+"}", url.PathEscape(parameterValueToString(r.clusterId, "clusterId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"export_id"+"}", url.PathEscape(parameterValueToString(r.exportId, "exportId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.ceph.api.v2.0+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiNfsGaneshaExportClusterIdExportIdPutRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiNfsGaneshaExportGetRequest struct {
	ctx context.Context
	ApiService *NFSGaneshaAPIService
}

func (r ApiApiNfsGaneshaExportGetRequest) Execute() ([]ApiNfsGaneshaExportGet200ResponseInner, *http.Response, error) {
	return r.ApiService.ApiNfsGaneshaExportGetExecute(r)
}

/*
ApiNfsGaneshaExportGet List all NFS-Ganesha exports

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiNfsGaneshaExportGetRequest
*/
func (a *NFSGaneshaAPIService) ApiNfsGaneshaExportGet(ctx context.Context) ApiApiNfsGaneshaExportGetRequest {
	return ApiApiNfsGaneshaExportGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ApiNfsGaneshaExportGet200ResponseInner
func (a *NFSGaneshaAPIService) ApiNfsGaneshaExportGetExecute(r ApiApiNfsGaneshaExportGetRequest) ([]ApiNfsGaneshaExportGet200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ApiNfsGaneshaExportGet200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NFSGaneshaAPIService.ApiNfsGaneshaExportGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/nfs-ganesha/export"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.ceph.api.v1.0+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiNfsGaneshaExportPostRequest struct {
	ctx context.Context
	ApiService *NFSGaneshaAPIService
	apiNfsGaneshaExportPostRequest *ApiNfsGaneshaExportPostRequest
}

func (r ApiApiNfsGaneshaExportPostRequest) ApiNfsGaneshaExportPostRequest(apiNfsGaneshaExportPostRequest ApiNfsGaneshaExportPostRequest) ApiApiNfsGaneshaExportPostRequest {
	r.apiNfsGaneshaExportPostRequest = &apiNfsGaneshaExportPostRequest
	return r
}

func (r ApiApiNfsGaneshaExportPostRequest) Execute() (*ApiNfsGaneshaExportPost201Response, *http.Response, error) {
	return r.ApiService.ApiNfsGaneshaExportPostExecute(r)
}

/*
ApiNfsGaneshaExportPost Creates a new NFS-Ganesha export

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiNfsGaneshaExportPostRequest
*/
func (a *NFSGaneshaAPIService) ApiNfsGaneshaExportPost(ctx context.Context) ApiApiNfsGaneshaExportPostRequest {
	return ApiApiNfsGaneshaExportPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiNfsGaneshaExportPost201Response
func (a *NFSGaneshaAPIService) ApiNfsGaneshaExportPostExecute(r ApiApiNfsGaneshaExportPostRequest) (*ApiNfsGaneshaExportPost201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiNfsGaneshaExportPost201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NFSGaneshaAPIService.ApiNfsGaneshaExportPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/nfs-ganesha/export"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.ceph.api.v2.0+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiNfsGaneshaExportPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
