/*
Ceph REST API

This is the official Ceph REST API

API version: v1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package ceph

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// OSDAPIService OSDAPI service
type OSDAPIService service

type ApiApiOsdFlagsGetRequest struct {
	ctx context.Context
	ApiService *OSDAPIService
}

func (r ApiApiOsdFlagsGetRequest) Execute() (*ApiOsdFlagsGet200Response, *http.Response, error) {
	return r.ApiService.ApiOsdFlagsGetExecute(r)
}

/*
ApiOsdFlagsGet Display OSD Flags

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiOsdFlagsGetRequest
*/
func (a *OSDAPIService) ApiOsdFlagsGet(ctx context.Context) ApiApiOsdFlagsGetRequest {
	return ApiApiOsdFlagsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiOsdFlagsGet200Response
func (a *OSDAPIService) ApiOsdFlagsGetExecute(r ApiApiOsdFlagsGetRequest) (*ApiOsdFlagsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiOsdFlagsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OSDAPIService.ApiOsdFlagsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/osd/flags"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.ceph.api.v1.0+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiOsdFlagsIndividualGetRequest struct {
	ctx context.Context
	ApiService *OSDAPIService
}

func (r ApiApiOsdFlagsIndividualGetRequest) Execute() (*ApiOsdFlagsIndividualGet200Response, *http.Response, error) {
	return r.ApiService.ApiOsdFlagsIndividualGetExecute(r)
}

/*
ApiOsdFlagsIndividualGet Displays individual OSD flags

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiOsdFlagsIndividualGetRequest
*/
func (a *OSDAPIService) ApiOsdFlagsIndividualGet(ctx context.Context) ApiApiOsdFlagsIndividualGetRequest {
	return ApiApiOsdFlagsIndividualGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiOsdFlagsIndividualGet200Response
func (a *OSDAPIService) ApiOsdFlagsIndividualGetExecute(r ApiApiOsdFlagsIndividualGetRequest) (*ApiOsdFlagsIndividualGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiOsdFlagsIndividualGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OSDAPIService.ApiOsdFlagsIndividualGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/osd/flags/individual"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.ceph.api.v1.0+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiOsdFlagsIndividualPutRequest struct {
	ctx context.Context
	ApiService *OSDAPIService
	apiOsdFlagsIndividualPutRequest *ApiOsdFlagsIndividualPutRequest
}

func (r ApiApiOsdFlagsIndividualPutRequest) ApiOsdFlagsIndividualPutRequest(apiOsdFlagsIndividualPutRequest ApiOsdFlagsIndividualPutRequest) ApiApiOsdFlagsIndividualPutRequest {
	r.apiOsdFlagsIndividualPutRequest = &apiOsdFlagsIndividualPutRequest
	return r
}

func (r ApiApiOsdFlagsIndividualPutRequest) Execute() (*ApiOsdFlagsIndividualPut200Response, *http.Response, error) {
	return r.ApiService.ApiOsdFlagsIndividualPutExecute(r)
}

/*
ApiOsdFlagsIndividualPut Sets OSD flags for a subset of individual OSDs.


        Updates flags (`noout`, `noin`, `nodown`, `noup`) for an individual
        subset of OSDs.
        

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiOsdFlagsIndividualPutRequest
*/
func (a *OSDAPIService) ApiOsdFlagsIndividualPut(ctx context.Context) ApiApiOsdFlagsIndividualPutRequest {
	return ApiApiOsdFlagsIndividualPutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiOsdFlagsIndividualPut200Response
func (a *OSDAPIService) ApiOsdFlagsIndividualPutExecute(r ApiApiOsdFlagsIndividualPutRequest) (*ApiOsdFlagsIndividualPut200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiOsdFlagsIndividualPut200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OSDAPIService.ApiOsdFlagsIndividualPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/osd/flags/individual"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.ceph.api.v1.0+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiOsdFlagsIndividualPutRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiOsdFlagsPutRequest struct {
	ctx context.Context
	ApiService *OSDAPIService
	apiOsdFlagsPutRequest *ApiOsdFlagsPutRequest
}

func (r ApiApiOsdFlagsPutRequest) ApiOsdFlagsPutRequest(apiOsdFlagsPutRequest ApiOsdFlagsPutRequest) ApiApiOsdFlagsPutRequest {
	r.apiOsdFlagsPutRequest = &apiOsdFlagsPutRequest
	return r
}

func (r ApiApiOsdFlagsPutRequest) Execute() (*ApiOsdFlagsGet200Response, *http.Response, error) {
	return r.ApiService.ApiOsdFlagsPutExecute(r)
}

/*
ApiOsdFlagsPut Sets OSD flags for the entire cluster.


        The `recovery_deletes`, `sortbitwise` and `pglog_hardlimit` flags cannot be unset.
        `purged_snapshots` cannot even be set. It is therefore required to at
        least include those four flags for a successful operation.
        

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiOsdFlagsPutRequest
*/
func (a *OSDAPIService) ApiOsdFlagsPut(ctx context.Context) ApiApiOsdFlagsPutRequest {
	return ApiApiOsdFlagsPutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiOsdFlagsGet200Response
func (a *OSDAPIService) ApiOsdFlagsPutExecute(r ApiApiOsdFlagsPutRequest) (*ApiOsdFlagsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiOsdFlagsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OSDAPIService.ApiOsdFlagsPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/osd/flags"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.ceph.api.v1.0+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiOsdFlagsPutRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiOsdGetRequest struct {
	ctx context.Context
	ApiService *OSDAPIService
	offset *int32
	limit *int32
	search *string
	sort *string
}

func (r ApiApiOsdGetRequest) Offset(offset int32) ApiApiOsdGetRequest {
	r.offset = &offset
	return r
}

func (r ApiApiOsdGetRequest) Limit(limit int32) ApiApiOsdGetRequest {
	r.limit = &limit
	return r
}

func (r ApiApiOsdGetRequest) Search(search string) ApiApiOsdGetRequest {
	r.search = &search
	return r
}

func (r ApiApiOsdGetRequest) Sort(sort string) ApiApiOsdGetRequest {
	r.sort = &sort
	return r
}

func (r ApiApiOsdGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiOsdGetExecute(r)
}

/*
ApiOsdGet Method for ApiOsdGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiOsdGetRequest
*/
func (a *OSDAPIService) ApiOsdGet(ctx context.Context) ApiApiOsdGetRequest {
	return ApiApiOsdGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *OSDAPIService) ApiOsdGetExecute(r ApiApiOsdGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OSDAPIService.ApiOsdGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/osd"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.ceph.api.v1.1+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiOsdPostRequest struct {
	ctx context.Context
	ApiService *OSDAPIService
	apiOsdPostRequest *ApiOsdPostRequest
}

func (r ApiApiOsdPostRequest) ApiOsdPostRequest(apiOsdPostRequest ApiOsdPostRequest) ApiApiOsdPostRequest {
	r.apiOsdPostRequest = &apiOsdPostRequest
	return r
}

func (r ApiApiOsdPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiOsdPostExecute(r)
}

/*
ApiOsdPost Method for ApiOsdPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiOsdPostRequest
*/
func (a *OSDAPIService) ApiOsdPost(ctx context.Context) ApiApiOsdPostRequest {
	return ApiApiOsdPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *OSDAPIService) ApiOsdPostExecute(r ApiApiOsdPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OSDAPIService.ApiOsdPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/osd"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.ceph.api.v1.0+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiOsdPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiOsdSafeToDeleteGetRequest struct {
	ctx context.Context
	ApiService *OSDAPIService
	svcIds *string
}

func (r ApiApiOsdSafeToDeleteGetRequest) SvcIds(svcIds string) ApiApiOsdSafeToDeleteGetRequest {
	r.svcIds = &svcIds
	return r
}

func (r ApiApiOsdSafeToDeleteGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiOsdSafeToDeleteGetExecute(r)
}

/*
ApiOsdSafeToDeleteGet Method for ApiOsdSafeToDeleteGet


        :type ids: int|[int]
        

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiOsdSafeToDeleteGetRequest
*/
func (a *OSDAPIService) ApiOsdSafeToDeleteGet(ctx context.Context) ApiApiOsdSafeToDeleteGetRequest {
	return ApiApiOsdSafeToDeleteGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *OSDAPIService) ApiOsdSafeToDeleteGetExecute(r ApiApiOsdSafeToDeleteGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OSDAPIService.ApiOsdSafeToDeleteGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/osd/safe_to_delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.svcIds == nil {
		return nil, reportError("svcIds is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "svc_ids", r.svcIds, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.ceph.api.v1.0+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiOsdSafeToDestroyGetRequest struct {
	ctx context.Context
	ApiService *OSDAPIService
	ids *string
}

// OSD Service Identifier
func (r ApiApiOsdSafeToDestroyGetRequest) Ids(ids string) ApiApiOsdSafeToDestroyGetRequest {
	r.ids = &ids
	return r
}

func (r ApiApiOsdSafeToDestroyGetRequest) Execute() (*ApiOsdSafeToDestroyGet200Response, *http.Response, error) {
	return r.ApiService.ApiOsdSafeToDestroyGetExecute(r)
}

/*
ApiOsdSafeToDestroyGet Check If OSD is Safe to Destroy


        :type ids: int|[int]
        

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiOsdSafeToDestroyGetRequest
*/
func (a *OSDAPIService) ApiOsdSafeToDestroyGet(ctx context.Context) ApiApiOsdSafeToDestroyGetRequest {
	return ApiApiOsdSafeToDestroyGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiOsdSafeToDestroyGet200Response
func (a *OSDAPIService) ApiOsdSafeToDestroyGetExecute(r ApiApiOsdSafeToDestroyGetRequest) (*ApiOsdSafeToDestroyGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiOsdSafeToDestroyGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OSDAPIService.ApiOsdSafeToDestroyGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/osd/safe_to_destroy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ids == nil {
		return localVarReturnValue, nil, reportError("ids is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "ids", r.ids, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.ceph.api.v1.0+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiOsdSettingsGetRequest struct {
	ctx context.Context
	ApiService *OSDAPIService
}

func (r ApiApiOsdSettingsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiOsdSettingsGetExecute(r)
}

/*
ApiOsdSettingsGet Method for ApiOsdSettingsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiOsdSettingsGetRequest
*/
func (a *OSDAPIService) ApiOsdSettingsGet(ctx context.Context) ApiApiOsdSettingsGetRequest {
	return ApiApiOsdSettingsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *OSDAPIService) ApiOsdSettingsGetExecute(r ApiApiOsdSettingsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OSDAPIService.ApiOsdSettingsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/osd/settings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.ceph.api.v0.1+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiOsdSvcIdDeleteRequest struct {
	ctx context.Context
	ApiService *OSDAPIService
	svcId string
	preserveId *string
	force *string
}

func (r ApiApiOsdSvcIdDeleteRequest) PreserveId(preserveId string) ApiApiOsdSvcIdDeleteRequest {
	r.preserveId = &preserveId
	return r
}

func (r ApiApiOsdSvcIdDeleteRequest) Force(force string) ApiApiOsdSvcIdDeleteRequest {
	r.force = &force
	return r
}

func (r ApiApiOsdSvcIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiOsdSvcIdDeleteExecute(r)
}

/*
ApiOsdSvcIdDelete Method for ApiOsdSvcIdDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param svcId
 @return ApiApiOsdSvcIdDeleteRequest
*/
func (a *OSDAPIService) ApiOsdSvcIdDelete(ctx context.Context, svcId string) ApiApiOsdSvcIdDeleteRequest {
	return ApiApiOsdSvcIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		svcId: svcId,
	}
}

// Execute executes the request
func (a *OSDAPIService) ApiOsdSvcIdDeleteExecute(r ApiApiOsdSvcIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OSDAPIService.ApiOsdSvcIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/osd/{svc_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"svc_id"+"}", url.PathEscape(parameterValueToString(r.svcId, "svcId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.preserveId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preserve_id", r.preserveId, "form", "")
	}
	if r.force != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "force", r.force, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.ceph.api.v1.0+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiOsdSvcIdDestroyPostRequest struct {
	ctx context.Context
	ApiService *OSDAPIService
	svcId string
}

func (r ApiApiOsdSvcIdDestroyPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiOsdSvcIdDestroyPostExecute(r)
}

/*
ApiOsdSvcIdDestroyPost Method for ApiOsdSvcIdDestroyPost


        Mark osd as being destroyed. Keeps the ID intact (allowing reuse), but
        removes cephx keys, config-key data and lockbox keys, rendering data
        permanently unreadable.

        The osd must be marked down before being destroyed.
        

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param svcId
 @return ApiApiOsdSvcIdDestroyPostRequest
*/
func (a *OSDAPIService) ApiOsdSvcIdDestroyPost(ctx context.Context, svcId string) ApiApiOsdSvcIdDestroyPostRequest {
	return ApiApiOsdSvcIdDestroyPostRequest{
		ApiService: a,
		ctx: ctx,
		svcId: svcId,
	}
}

// Execute executes the request
func (a *OSDAPIService) ApiOsdSvcIdDestroyPostExecute(r ApiApiOsdSvcIdDestroyPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OSDAPIService.ApiOsdSvcIdDestroyPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/osd/{svc_id}/destroy"
	localVarPath = strings.Replace(localVarPath, "{"+"svc_id"+"}", url.PathEscape(parameterValueToString(r.svcId, "svcId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.ceph.api.v1.0+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiOsdSvcIdDevicesGetRequest struct {
	ctx context.Context
	ApiService *OSDAPIService
	svcId string
}

func (r ApiApiOsdSvcIdDevicesGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiOsdSvcIdDevicesGetExecute(r)
}

/*
ApiOsdSvcIdDevicesGet Method for ApiOsdSvcIdDevicesGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param svcId
 @return ApiApiOsdSvcIdDevicesGetRequest
*/
func (a *OSDAPIService) ApiOsdSvcIdDevicesGet(ctx context.Context, svcId string) ApiApiOsdSvcIdDevicesGetRequest {
	return ApiApiOsdSvcIdDevicesGetRequest{
		ApiService: a,
		ctx: ctx,
		svcId: svcId,
	}
}

// Execute executes the request
func (a *OSDAPIService) ApiOsdSvcIdDevicesGetExecute(r ApiApiOsdSvcIdDevicesGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OSDAPIService.ApiOsdSvcIdDevicesGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/osd/{svc_id}/devices"
	localVarPath = strings.Replace(localVarPath, "{"+"svc_id"+"}", url.PathEscape(parameterValueToString(r.svcId, "svcId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.ceph.api.v1.0+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiOsdSvcIdGetRequest struct {
	ctx context.Context
	ApiService *OSDAPIService
	svcId string
}

func (r ApiApiOsdSvcIdGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiOsdSvcIdGetExecute(r)
}

/*
ApiOsdSvcIdGet Method for ApiOsdSvcIdGet


        Returns collected data about an OSD.

        :return: Returns the requested data.
        

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param svcId
 @return ApiApiOsdSvcIdGetRequest
*/
func (a *OSDAPIService) ApiOsdSvcIdGet(ctx context.Context, svcId string) ApiApiOsdSvcIdGetRequest {
	return ApiApiOsdSvcIdGetRequest{
		ApiService: a,
		ctx: ctx,
		svcId: svcId,
	}
}

// Execute executes the request
func (a *OSDAPIService) ApiOsdSvcIdGetExecute(r ApiApiOsdSvcIdGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OSDAPIService.ApiOsdSvcIdGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/osd/{svc_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"svc_id"+"}", url.PathEscape(parameterValueToString(r.svcId, "svcId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.ceph.api.v1.0+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiOsdSvcIdHistogramGetRequest struct {
	ctx context.Context
	ApiService *OSDAPIService
	svcId string
}

func (r ApiApiOsdSvcIdHistogramGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiOsdSvcIdHistogramGetExecute(r)
}

/*
ApiOsdSvcIdHistogramGet Method for ApiOsdSvcIdHistogramGet


        :return: Returns the histogram data.
        

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param svcId
 @return ApiApiOsdSvcIdHistogramGetRequest
*/
func (a *OSDAPIService) ApiOsdSvcIdHistogramGet(ctx context.Context, svcId string) ApiApiOsdSvcIdHistogramGetRequest {
	return ApiApiOsdSvcIdHistogramGetRequest{
		ApiService: a,
		ctx: ctx,
		svcId: svcId,
	}
}

// Execute executes the request
func (a *OSDAPIService) ApiOsdSvcIdHistogramGetExecute(r ApiApiOsdSvcIdHistogramGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OSDAPIService.ApiOsdSvcIdHistogramGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/osd/{svc_id}/histogram"
	localVarPath = strings.Replace(localVarPath, "{"+"svc_id"+"}", url.PathEscape(parameterValueToString(r.svcId, "svcId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.ceph.api.v1.0+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiOsdSvcIdMarkPutRequest struct {
	ctx context.Context
	ApiService *OSDAPIService
	svcId string
	apiOsdSvcIdMarkPutRequest *ApiOsdSvcIdMarkPutRequest
}

func (r ApiApiOsdSvcIdMarkPutRequest) ApiOsdSvcIdMarkPutRequest(apiOsdSvcIdMarkPutRequest ApiOsdSvcIdMarkPutRequest) ApiApiOsdSvcIdMarkPutRequest {
	r.apiOsdSvcIdMarkPutRequest = &apiOsdSvcIdMarkPutRequest
	return r
}

func (r ApiApiOsdSvcIdMarkPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiOsdSvcIdMarkPutExecute(r)
}

/*
ApiOsdSvcIdMarkPut Mark OSD flags (out, in, down, lost, ...)


        Note: osd must be marked `down` before marking lost.
        

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param svcId SVC ID
 @return ApiApiOsdSvcIdMarkPutRequest
*/
func (a *OSDAPIService) ApiOsdSvcIdMarkPut(ctx context.Context, svcId string) ApiApiOsdSvcIdMarkPutRequest {
	return ApiApiOsdSvcIdMarkPutRequest{
		ApiService: a,
		ctx: ctx,
		svcId: svcId,
	}
}

// Execute executes the request
func (a *OSDAPIService) ApiOsdSvcIdMarkPutExecute(r ApiApiOsdSvcIdMarkPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OSDAPIService.ApiOsdSvcIdMarkPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/osd/{svc_id}/mark"
	localVarPath = strings.Replace(localVarPath, "{"+"svc_id"+"}", url.PathEscape(parameterValueToString(r.svcId, "svcId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.ceph.api.v1.0+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiOsdSvcIdMarkPutRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiOsdSvcIdPurgePostRequest struct {
	ctx context.Context
	ApiService *OSDAPIService
	svcId string
}

func (r ApiApiOsdSvcIdPurgePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiOsdSvcIdPurgePostExecute(r)
}

/*
ApiOsdSvcIdPurgePost Method for ApiOsdSvcIdPurgePost


        Note: osd must be marked `down` before removal.
        

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param svcId
 @return ApiApiOsdSvcIdPurgePostRequest
*/
func (a *OSDAPIService) ApiOsdSvcIdPurgePost(ctx context.Context, svcId string) ApiApiOsdSvcIdPurgePostRequest {
	return ApiApiOsdSvcIdPurgePostRequest{
		ApiService: a,
		ctx: ctx,
		svcId: svcId,
	}
}

// Execute executes the request
func (a *OSDAPIService) ApiOsdSvcIdPurgePostExecute(r ApiApiOsdSvcIdPurgePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OSDAPIService.ApiOsdSvcIdPurgePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/osd/{svc_id}/purge"
	localVarPath = strings.Replace(localVarPath, "{"+"svc_id"+"}", url.PathEscape(parameterValueToString(r.svcId, "svcId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.ceph.api.v1.0+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiOsdSvcIdPutRequest struct {
	ctx context.Context
	ApiService *OSDAPIService
	svcId string
	apiOsdSvcIdPutRequest *ApiOsdSvcIdPutRequest
}

func (r ApiApiOsdSvcIdPutRequest) ApiOsdSvcIdPutRequest(apiOsdSvcIdPutRequest ApiOsdSvcIdPutRequest) ApiApiOsdSvcIdPutRequest {
	r.apiOsdSvcIdPutRequest = &apiOsdSvcIdPutRequest
	return r
}

func (r ApiApiOsdSvcIdPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiOsdSvcIdPutExecute(r)
}

/*
ApiOsdSvcIdPut Method for ApiOsdSvcIdPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param svcId
 @return ApiApiOsdSvcIdPutRequest
*/
func (a *OSDAPIService) ApiOsdSvcIdPut(ctx context.Context, svcId string) ApiApiOsdSvcIdPutRequest {
	return ApiApiOsdSvcIdPutRequest{
		ApiService: a,
		ctx: ctx,
		svcId: svcId,
	}
}

// Execute executes the request
func (a *OSDAPIService) ApiOsdSvcIdPutExecute(r ApiApiOsdSvcIdPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OSDAPIService.ApiOsdSvcIdPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/osd/{svc_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"svc_id"+"}", url.PathEscape(parameterValueToString(r.svcId, "svcId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.ceph.api.v1.0+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiOsdSvcIdPutRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiOsdSvcIdReweightPostRequest struct {
	ctx context.Context
	ApiService *OSDAPIService
	svcId string
	apiOsdSvcIdReweightPostRequest *ApiOsdSvcIdReweightPostRequest
}

func (r ApiApiOsdSvcIdReweightPostRequest) ApiOsdSvcIdReweightPostRequest(apiOsdSvcIdReweightPostRequest ApiOsdSvcIdReweightPostRequest) ApiApiOsdSvcIdReweightPostRequest {
	r.apiOsdSvcIdReweightPostRequest = &apiOsdSvcIdReweightPostRequest
	return r
}

func (r ApiApiOsdSvcIdReweightPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiOsdSvcIdReweightPostExecute(r)
}

/*
ApiOsdSvcIdReweightPost Method for ApiOsdSvcIdReweightPost


        Reweights the OSD temporarily.

        Note that ‘ceph osd reweight’ is not a persistent setting. When an OSD
        gets marked out, the osd weight will be set to 0. When it gets marked
        in again, the weight will be changed to 1.

        Because of this ‘ceph osd reweight’ is a temporary solution. You should
        only use it to keep your cluster running while you’re ordering more
        hardware.

        - Craig Lewis (http://lists.ceph.com/pipermail/ceph-users-ceph.com/2014-June/040967.html)
        

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param svcId
 @return ApiApiOsdSvcIdReweightPostRequest
*/
func (a *OSDAPIService) ApiOsdSvcIdReweightPost(ctx context.Context, svcId string) ApiApiOsdSvcIdReweightPostRequest {
	return ApiApiOsdSvcIdReweightPostRequest{
		ApiService: a,
		ctx: ctx,
		svcId: svcId,
	}
}

// Execute executes the request
func (a *OSDAPIService) ApiOsdSvcIdReweightPostExecute(r ApiApiOsdSvcIdReweightPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OSDAPIService.ApiOsdSvcIdReweightPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/osd/{svc_id}/reweight"
	localVarPath = strings.Replace(localVarPath, "{"+"svc_id"+"}", url.PathEscape(parameterValueToString(r.svcId, "svcId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.ceph.api.v1.0+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiOsdSvcIdReweightPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiOsdSvcIdScrubPostRequest struct {
	ctx context.Context
	ApiService *OSDAPIService
	svcId string
	deep *bool
	apiOsdSvcIdScrubPostRequest *ApiOsdSvcIdScrubPostRequest
}

func (r ApiApiOsdSvcIdScrubPostRequest) Deep(deep bool) ApiApiOsdSvcIdScrubPostRequest {
	r.deep = &deep
	return r
}

func (r ApiApiOsdSvcIdScrubPostRequest) ApiOsdSvcIdScrubPostRequest(apiOsdSvcIdScrubPostRequest ApiOsdSvcIdScrubPostRequest) ApiApiOsdSvcIdScrubPostRequest {
	r.apiOsdSvcIdScrubPostRequest = &apiOsdSvcIdScrubPostRequest
	return r
}

func (r ApiApiOsdSvcIdScrubPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiOsdSvcIdScrubPostExecute(r)
}

/*
ApiOsdSvcIdScrubPost Method for ApiOsdSvcIdScrubPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param svcId
 @return ApiApiOsdSvcIdScrubPostRequest
*/
func (a *OSDAPIService) ApiOsdSvcIdScrubPost(ctx context.Context, svcId string) ApiApiOsdSvcIdScrubPostRequest {
	return ApiApiOsdSvcIdScrubPostRequest{
		ApiService: a,
		ctx: ctx,
		svcId: svcId,
	}
}

// Execute executes the request
func (a *OSDAPIService) ApiOsdSvcIdScrubPostExecute(r ApiApiOsdSvcIdScrubPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OSDAPIService.ApiOsdSvcIdScrubPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/osd/{svc_id}/scrub"
	localVarPath = strings.Replace(localVarPath, "{"+"svc_id"+"}", url.PathEscape(parameterValueToString(r.svcId, "svcId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deep != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deep", r.deep, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.ceph.api.v1.0+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiOsdSvcIdScrubPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiOsdSvcIdSmartGetRequest struct {
	ctx context.Context
	ApiService *OSDAPIService
	svcId string
}

func (r ApiApiOsdSvcIdSmartGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiOsdSvcIdSmartGetExecute(r)
}

/*
ApiOsdSvcIdSmartGet Method for ApiOsdSvcIdSmartGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param svcId
 @return ApiApiOsdSvcIdSmartGetRequest
*/
func (a *OSDAPIService) ApiOsdSvcIdSmartGet(ctx context.Context, svcId string) ApiApiOsdSvcIdSmartGetRequest {
	return ApiApiOsdSvcIdSmartGetRequest{
		ApiService: a,
		ctx: ctx,
		svcId: svcId,
	}
}

// Execute executes the request
func (a *OSDAPIService) ApiOsdSvcIdSmartGetExecute(r ApiApiOsdSvcIdSmartGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OSDAPIService.ApiOsdSvcIdSmartGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/osd/{svc_id}/smart"
	localVarPath = strings.Replace(localVarPath, "{"+"svc_id"+"}", url.PathEscape(parameterValueToString(r.svcId, "svcId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.ceph.api.v1.0+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
